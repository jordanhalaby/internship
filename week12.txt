Week 12 7/16/18 - 7/20/18
	Monday 7/16/18
		Since it's been a while since I began training the Wit API, I found it necessary to start re-familiarizing myself with
			the structure of entities that i concoted a few weeks ago.
		The way i set it up (which i will explain more in depth later in this report) was to figure out if the user has asked
			a question or posed a problem. From there, I will diagnose the question and/or problem and respond with a 
			pre-formulated response generated by SimpleNLG
		If the user inputs a problem, it is addressed simply by giving a response that is drawn from a databank of common user problems
		If the user inputs a question, however, we use the created entities to focus in on what exactly they are asking on any particular form
			The way that this structure will behave will be described later
		From my list of training questions that i created while training the Wit API, I selected a few with the intention of figuring out how 
			my structure works. While i was doing that, i added more training input so that I could train Wit without having to add any additional entities
		I decided that for statements (which most of them are questions worded differently), i will regard them as questions when creating training and test data
	Tuesday 7/17/18
		I began creating an outline of all the entities, intents, keywords, and traits that were generated from me training the Wit API. I decided to focus only on 
		questions and statements but ignore problem user input for now
		My goal for the outline is to parse the user input into a specific list of attributes that don't produce an accurate response after being
		ran through the path of the decision tree. If the user provides input that generates one of these invalid statements, the default 
		"Please re-phrase your input" is returned to the user. As mentioned in a previous report, if this resposne occurs 3 times, 
		the user is redirected to our general HR number
			To begin, i wrote down the list of entities so that i can cross them off as I go through them
			Then, one entity at a time I began creating an outline that will allow the decision tree to navigate it and produce test data. 
				I will create the training data in a similar manner later on in the week
				It was time-consuming and tedius due to the variety and volume of these entities
			After the first half hour or so, i realized that my current method may be insufficient to track all that is going on in the Wit API
				So i decided to finish going through all the entities and try to create the outline that way
				Then I decided to go through each of the training questions to ensure that each of them are in some way represented by the outline
	Wednesday 7/18/18
		After a long process of creating my outline on Tuesday, the way that it works, with the Wit API, is the following
			First the Wit API determines if the user is asking a question or posing a problem
			Then for questions, it determines what kind of question is being asked (What, Who, When, Where, etc)
			For each of these question types, I determine what kind of topic is being asked
			After that, I determine what the actual object (or noun) is being asked about
		In order to create the training data for the decision tree, I need to be crafty with how i represent all entities but simulatenously 
		keep it concise. Also, to keep in mind, my decision tree algorithm only accepts attributes that are binary types
			So to do this, I will represent each entity by a binary number that is generated by on/off switches
				For example, lets say that we have an entity: question-type, 
				which has the following keywords: where, can, who, when, should, why, do, which, what, does, how
				Where would be represented by 0, can by 1, who by 2, when by 3, etc.
				So for the keyword 'what', represented by the number 8 or, in binary, 1000
					In my training data, it will be represented by: "question-type-on question-type-off question-type-off question-type-off"
				Another example, the keyword when, represented by the number 3 or, in binary, 0011
					In my training data, it will be represented by: "question-type-of question-type-off question-type-on question-type-on"
			I am going to do a similar thing with the form names so that i can keep track of which form is being referenced in the question
				Example: form-off form-on form-on form-off would represent the 6th form
				To do this, i created a list of all the forms that I was given that have frequently asked questions
					Then i assigned a number, in base 10, to each form starting with 0 and going up to 19
					Then i converted that number into binary
	Thursday 7/19/18
		Picked back up on working on the ruby code that will run the Chat bot
			I began by getting the name of the form from the user input. Once the chat-bot is pushed to the live site, we will be able to obtain the form name
			based on where the chatbot is sitting at the time of use. Since it is currently being used solely on the command line, I had to get creative with 
			figuring out the name of the form.
				To do this, i began by creating an array of the names of the forms that have the potential for questions to be asked about them
				I modified the "getForm" method so that it takes the user input as a parameter, which is of the format 1||message where 1 represents the index of the form in the array
					i split the double bars || on the user input and get the first element of the array that resulted in that split
					Then i check to see if the given number is less that the array of form names (so that I have a valid index of the array)
					Then i return the name of the form given by passing the number into the array of form names				
			When the "type" of input ("type" is a Wit API entity) is a question, I call a method called "process_form" that is given the user input as a parameter
				Inside of this method I check to see if the given user input contains the double bars ||
					If so, i get the form name using the "getForm" method
					Otherwise, I return an error statement: "You must specify a form in this format: 1||message"
				This is done so that i can simulatenously check to see if there is correct formatting and get the form name